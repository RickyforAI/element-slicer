<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>元素切切乐 - Element Slicer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            max-width: 100vw;
            max-height: 100vh;
        }
        
        #game-canvas {
            border: 2px solid #16213e;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(94, 84, 142, 0.5);
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 24px;
            text-align: center;
        }
        
        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-left: 10px;
            border: 3px solid #fff;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div class="loading" id="loading">加载中</div>
    </div>
    
    <!-- 引入 Phaser 3.70.0 -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    
    <script>
    // ==================== 游戏架构 ====================
    const ElementSlicer = {
        // 配置系统 - 所有可调参数集中管理
        Config: {
            canvas: {
                width: 800,
                height: 600
            },
            
            // 游戏配置
            game: {
                targetScore: 300,       // 目标分数
                initialLives: 3,        // 初始生命值
                spawnInterval: 2000,    // 初始生成间隔（毫秒）
                minSpawnInterval: 1000, // 最小生成间隔
                gravity: 300            // 重力值
            },
            
            // 元素配置
            elements: {
                radius: 40,             // 元素半径
                initialVelocityY: -400, // 初始向上速度
                rotationSpeed: 2,       // 旋转速度
                
                // 元素类型定义
                types: {
                    normal: {
                        symbols: ['C', 'N', 'O', 'H'],
                        color: 0x4A90E2,    // 蓝色
                        score: 5,
                        name: '普通元素'
                    },
                    toxic: {
                        symbols: ['F', 'Cl', 'Br'],
                        color: 0x4CAF50,    // 绿色
                        score: 8,
                        name: '毒雾元素'
                    },
                    phantom: {
                        symbols: ['He', 'Ne', 'Ar'],
                        color: 0x00BCD4,    // 青色
                        score: 15,
                        health: 3,          // 需要切3次
                        name: '幻影元素'
                    },
                    explosive: {
                        symbols: ['Li', 'Na', 'K'],
                        color: 0xFF4444,    // 红色
                        score: 0,
                        damage: 1,          // 扣除生命值
                        name: '爆裂元素'
                    }
                }
            },
            
            // UI配置
            ui: {
                fontSize: 24,
                fontFamily: 'Arial',
                colors: {
                    text: '#FFFFFF',
                    score: '#FFD700',
                    lives: '#FF6B6B'
                }
            },
            
            // 版本信息
            version: '0.2.0'
        },
        
        // 游戏状态 - 全局状态管理
        State: {
            gameState: 'loading',   // loading, menu, playing, paused, gameover
            score: 0,
            lives: 3,
            combo: 0,
            maxCombo: 0,
            level: 1,
            elementsSpawned: 0,
            elementsSliced: 0,
            currentSpawnInterval: 2000
        },
        
        // 核心系统
        Systems: {},
        
        // 工具函数
        Utils: {
            /**
             * 生成指定范围的随机数
             */
            random: function(min, max) {
                return Math.random() * (max - min) + min;
            },
            
            /**
             * 计算两点之间的距离
             */
            distance: function(x1, y1, x2, y2) {
                const dx = x2 - x1;
                const dy = y2 - y1;
                return Math.sqrt(dx * dx + dy * dy);
            },
            
            /**
             * 线性插值
             */
            lerp: function(a, b, t) {
                return a + (b - a) * t;
            }
        },
        
        // 开发日志
        DevLog: {
            entries: [],
            
            log: function(action, details) {
                this.entries.push({
                    timestamp: new Date().toISOString(),
                    action: action,
                    details: details,
                    version: ElementSlicer.Config.version
                });
                console.log(`[DevLog] ${action}:`, details);
            }
        }
    };
    
    // ==================== Phaser 场景定义 ====================
    class GameScene extends Phaser.Scene {
        constructor() {
            super({ key: 'GameScene' });
            
            // 场景变量
            this.elements = null;       // 元素组
            this.sliceGraphics = null;  // 切割轨迹
            this.scoreText = null;      // 分数文本
            this.livesText = null;      // 生命值文本
            this.comboText = null;      // 连击文本
            this.background = null;     // 背景
            
            // 切割相关
            this.isSlicing = false;
            this.slicePoints = [];
            
            // 生成定时器
            this.spawnTimer = null;
        }
        
        /**
         * 预加载资源
         */
        preload() {
            // 创建加载进度条
            const progressBar = this.add.graphics();
            const progressBox = this.add.graphics();
            progressBox.fillStyle(0x222222, 0.8);
            progressBox.fillRect(240, 270, 320, 50);
            
            const width = this.cameras.main.width;
            const height = this.cameras.main.height;
            const loadingText = this.make.text({
                x: width / 2,
                y: height / 2 - 50,
                text: '加载中...',
                style: {
                    font: '20px Arial',
                    fill: '#ffffff'
                }
            });
            loadingText.setOrigin(0.5, 0.5);
            
            // 监听加载进度
            this.load.on('progress', function (value) {
                progressBar.clear();
                progressBar.fillStyle(0xffffff, 1);
                progressBar.fillRect(250, 280, 300 * value, 30);
            });
            
            // 加载完成
            this.load.on('complete', function () {
                progressBar.destroy();
                progressBox.destroy();
                loadingText.destroy();
                ElementSlicer.DevLog.log('ASSETS_LOADED', '资源加载完成');
            });
            
            // 动态创建圆形纹理
            this.load.on('start', () => {
                // 创建不同颜色的圆形纹理
                const colors = {
                    'normal': 0x4A90E2,
                    'toxic': 0x4CAF50,
                    'phantom': 0x00BCD4,
                    'explosive': 0xFF4444
                };
                
                for (let type in colors) {
                    const graphics = this.make.graphics({ x: 0, y: 0 });
                    graphics.fillStyle(colors[type], 1);
                    graphics.fillCircle(40, 40, 40);
                    graphics.generateTexture('element_' + type, 80, 80);
                    graphics.destroy();
                }
            });
            
            this.load.start();
        }
        
        /**
         * 创建游戏场景
         */
        create() {
            ElementSlicer.DevLog.log('SCENE_CREATED', '游戏场景创建');
            
            // 隐藏加载提示
            document.getElementById('loading').style.display = 'none';
            
            // 创建紫色渐变背景
            this.createBackground();
            
            // 创建UI
            this.createUI();
            
            // 创建元素组
            this.elements = this.physics.add.group();
            
            // 创建切割轨迹图形
            this.sliceGraphics = this.add.graphics();
            
            // 设置输入事件
            this.setupInput();
            
            // 开始游戏
            this.startGame();
        }
        
        /**
         * 创建背景
         */
        createBackground() {
            // 创建渐变背景
            const graphics = this.add.graphics();
            
            // 深紫到浅紫的渐变
            const color1 = 0x1a1a2e;  // 深紫
            const color2 = 0x16213e;  // 中紫
            const color3 = 0x0f3460;  // 浅紫
            
            // 绘制渐变矩形
            for (let i = 0; i < 100; i++) {
                const color = Phaser.Display.Color.Interpolate.ColorWithColor(
                    Phaser.Display.Color.ValueToColor(color1),
                    Phaser.Display.Color.ValueToColor(color3),
                    100,
                    i
                );
                graphics.fillStyle(color.color, 1);
                graphics.fillRect(0, i * 6, 800, 6);
            }
            
            this.background = graphics;
        }
        
        /**
         * 创建UI界面
         */
        createUI() {
            const config = ElementSlicer.Config;
            
            // 游戏标题
            this.add.text(config.canvas.width / 2, 30, '元素切切乐', {
                fontSize: '36px',
                fontFamily: config.ui.fontFamily,
                color: config.ui.colors.text,
                stroke: '#000000',
                strokeThickness: 4
            }).setOrigin(0.5);
            
            // 分数显示
            this.scoreText = this.add.text(20, 20, '分数: 0', {
                fontSize: config.ui.fontSize + 'px',
                fontFamily: config.ui.fontFamily,
                color: config.ui.colors.score
            });
            
            // 生命值显示
            this.livesText = this.add.text(20, 60, '生命: ❤️❤️❤️', {
                fontSize: config.ui.fontSize + 'px',
                fontFamily: config.ui.fontFamily,
                color: config.ui.colors.lives
            });
            
            // 连击显示（初始隐藏）
            this.comboText = this.add.text(config.canvas.width / 2, 100, '', {
                fontSize: '32px',
                fontFamily: config.ui.fontFamily,
                color: '#FFD700',
                stroke: '#000000',
                strokeThickness: 4
            }).setOrigin(0.5).setAlpha(0);
            
            // 目标分数提示
            this.add.text(config.canvas.width - 20, 20, 
                `目标: ${config.game.targetScore}分`, {
                fontSize: '20px',
                fontFamily: config.ui.fontFamily,
                color: '#FFFFFF',
                align: 'right'
            }).setOrigin(1, 0);
        }
        
        /**
         * 设置输入事件
         */
        setupInput() {
            // 鼠标/触摸开始
            this.input.on('pointerdown', (pointer) => {
                this.startSlice(pointer);
            });
            
            // 鼠标/触摸移动
            this.input.on('pointermove', (pointer) => {
                if (this.isSlicing) {
                    this.updateSlice(pointer);
                }
            });
            
            // 鼠标/触摸结束
            this.input.on('pointerup', () => {
                this.endSlice();
            });
            
            // 键盘事件（调试用）
            this.input.keyboard.on('keydown-P', () => {
                this.togglePause();
            });
        }
        
        /**
         * 开始游戏
         */
        startGame() {
            ElementSlicer.State.gameState = 'playing';
            ElementSlicer.State.score = 0;
            ElementSlicer.State.lives = ElementSlicer.Config.game.initialLives;
            ElementSlicer.State.combo = 0;
            
            // 开始生成元素
            this.startElementSpawning();
            
            ElementSlicer.DevLog.log('GAME_STARTED', '游戏开始');
        }
        
        /**
         * 开始生成元素
         */
        startElementSpawning() {
            // 立即生成第一个元素
            this.spawnElement();
            
            // 设置定时生成
            this.spawnTimer = this.time.addEvent({
                delay: ElementSlicer.State.currentSpawnInterval,
                callback: this.spawnElement,
                callbackScope: this,
                loop: true
            });
        }
        
        /**
         * 生成元素
         */
        spawnElement() {
            // 随机选择元素类型
            const types = ['normal', 'toxic', 'phantom', 'explosive'];
            const weights = [0.5, 0.2, 0.15, 0.15]; // 普通元素出现概率更高
            
            // 根据权重选择类型
            let random = Math.random();
            let typeIndex = 0;
            let sum = 0;
            for (let i = 0; i < weights.length; i++) {
                sum += weights[i];
                if (random < sum) {
                    typeIndex = i;
                    break;
                }
            }
            
            const elementType = types[typeIndex];
            const typeConfig = ElementSlicer.Config.elements.types[elementType];
            
            // 随机选择该类型的一个符号
            const symbol = typeConfig.symbols[Math.floor(Math.random() * typeConfig.symbols.length)];
            
            const x = ElementSlicer.Utils.random(100, 700);
            const y = 650; // 从屏幕底部下方开始
            
            // 使用预加载的纹理创建元素
            const element = this.physics.add.image(x, y, 'element_' + elementType);
            element.setDisplaySize(80, 80);
            element.body.setVelocity(
                ElementSlicer.Utils.random(-50, 50), // 轻微的水平速度
                ElementSlicer.Config.elements.initialVelocityY
            );
            element.body.setGravity(0, ElementSlicer.Config.game.gravity);
            
            // 添加元素属性
            element.elementType = elementType;
            element.symbol = symbol;
            element.score = typeConfig.score;
            element.damage = typeConfig.damage || 0;
            element.health = typeConfig.health || 1;
            element.isSliced = false;
            element.fillColor = typeConfig.color;
            
            // 添加元素符号文本
            const symbolText = this.add.text(x, y, symbol, {
                fontSize: '28px',
                fontFamily: 'Arial',
                color: '#FFFFFF',
                stroke: '#000000',
                strokeThickness: 2
            }).setOrigin(0.5);
            
            element.symbolText = symbolText;
            
            // 为特殊元素添加视觉效果
            if (elementType === 'phantom') {
                // 幻影元素：半透明效果
                element.setAlpha(0.7);
                
                // 添加闪烁效果
                this.tweens.add({
                    targets: element,
                    alpha: 0.3,
                    duration: 1000,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
            } else if (elementType === 'explosive') {
                // 爆裂元素：脉动效果
                this.tweens.add({
                    targets: element,
                    scaleX: 1.1,
                    scaleY: 1.1,
                    duration: 500,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
            }
            
            // 添加到元素组
            this.elements.add(element);
            
            ElementSlicer.State.elementsSpawned++;
            
            // 调试信息
            console.log(`生成元素: ${elementType} (${symbol}) at (${x}, ${y})`);
            console.log(`元素总数: ${this.elements.children.entries.length}`);
        }
        
        /**
         * 开始切割
         */
        startSlice(pointer) {
            this.isSlicing = true;
            this.slicePoints = [{ x: pointer.x, y: pointer.y }];
        }
        
        /**
         * 更新切割轨迹
         */
        updateSlice(pointer) {
            if (!this.isSlicing) return;
            
            // 添加新点
            this.slicePoints.push({ x: pointer.x, y: pointer.y });
            
            // 限制点数量
            if (this.slicePoints.length > 20) {
                this.slicePoints.shift();
            }
            
            // 绘制轨迹
            this.drawSliceTrail();
            
            // 检测碰撞
            this.checkSliceCollision(pointer);
        }
        
        /**
         * 结束切割
         */
        endSlice() {
            this.isSlicing = false;
            this.slicePoints = [];
            this.sliceGraphics.clear();
        }
        
        /**
         * 绘制切割轨迹
         */
        drawSliceTrail() {
            this.sliceGraphics.clear();
            
            if (this.slicePoints.length < 2) return;
            
            // 设置线条样式
            this.sliceGraphics.lineStyle(4, 0xFFFFFF, 1);
            
            // 绘制轨迹
            this.sliceGraphics.beginPath();
            this.sliceGraphics.moveTo(this.slicePoints[0].x, this.slicePoints[0].y);
            
            for (let i = 1; i < this.slicePoints.length; i++) {
                const alpha = i / this.slicePoints.length;
                this.sliceGraphics.lineStyle(4, 0xFFFFFF, alpha);
                this.sliceGraphics.lineTo(this.slicePoints[i].x, this.slicePoints[i].y);
            }
            
            this.sliceGraphics.strokePath();
            
            // 添加发光效果
            this.sliceGraphics.lineStyle(8, 0xFFFFFF, 0.3);
            this.sliceGraphics.strokePath();
        }
        
        /**
         * 检测切割碰撞
         */
        checkSliceCollision(pointer) {
            this.elements.children.entries.forEach(element => {
                if (!element.active) return;
                
                const distance = ElementSlicer.Utils.distance(
                    pointer.x, pointer.y,
                    element.x, element.y
                );
                
                if (distance < ElementSlicer.Config.elements.radius + 10) {
                    this.sliceElement(element);
                }
            });
        }
        
        /**
         * 切割元素
         */
        sliceElement(element) {
            if (element.isSliced) return; // 防止重复切割
            
            // 根据元素类型执行不同行为
            switch (element.elementType) {
                case 'normal':
                    this.handleNormalSlice(element);
                    break;
                    
                case 'toxic':
                    this.handleToxicSlice(element);
                    break;
                    
                case 'phantom':
                    this.handlePhantomSlice(element);
                    break;
                    
                case 'explosive':
                    this.handleExplosiveSlice(element);
                    break;
            }
        }
        
        /**
         * 处理普通元素切割
         */
        handleNormalSlice(element) {
            // 更新分数
            ElementSlicer.State.score += element.score;
            this.updateScore();
            
            // 显示得分动画
            this.showScorePopup(element.x, element.y, element.score);
            
            // 创建切割特效
            this.createSliceEffect(element.x, element.y, 0x4A90E2);
            
            // 移除元素
            this.destroyElement(element);
            
            // 更新连击
            this.updateCombo();
        }
        
        /**
         * 处理毒雾元素切割
         */
        handleToxicSlice(element) {
            // 更新分数
            ElementSlicer.State.score += element.score;
            this.updateScore();
            
            // 显示得分动画
            this.showScorePopup(element.x, element.y, element.score);
            
            // 创建毒雾效果
            this.createToxicFog(element.x, element.y);
            
            // 移除元素
            this.destroyElement(element);
            
            // 更新连击
            this.updateCombo();
        }
        
        /**
         * 处理幻影元素切割
         */
        handlePhantomSlice(element) {
            element.health--;
            
            if (element.health > 0) {
                // 还需要继续切割
                this.createPhantomHitEffect(element);
                
                // 加速逃跑
                const currentVelocity = element.body.velocity;
                element.body.setVelocity(
                    currentVelocity.x * 1.5,
                    currentVelocity.y * 1.2
                );
                
                // 显示剩余切割次数
                this.showFloatingText(element.x, element.y - 50, 
                    `还需${element.health}次!`, '#00BCD4');
            } else {
                // 完成切割
                ElementSlicer.State.score += element.score;
                this.updateScore();
                
                // 显示得分动画
                this.showScorePopup(element.x, element.y, element.score);
                
                // 创建幻影消散效果
                this.createPhantomDestroyEffect(element.x, element.y);
                
                // 移除元素
                this.destroyElement(element);
                
                // 更新连击
                this.updateCombo();
            }
        }
        
        /**
         * 处理爆裂元素切割
         */
        handleExplosiveSlice(element) {
            // 扣除生命值
            if (ElementSlicer.State.lives > 0) {
                ElementSlicer.State.lives--;
                this.updateLives();
            }
            
            // 创建爆炸效果
            this.createExplosion(element.x, element.y);
            
            // 屏幕震动
            this.cameras.main.shake(300, 0.02);
            
            // 显示警告
            this.showFloatingText(element.x, element.y, '-1 生命!', '#FF4444');
            
            // 移除元素
            this.destroyElement(element);
            
            // 重置连击
            ElementSlicer.State.combo = 0;
            this.hideCombo();
            
            // 检查游戏结束
            if (ElementSlicer.State.lives <= 0) {
                this.gameOver();
            }
        }
        
        /**
         * 销毁元素
         */
        destroyElement(element) {
            element.isSliced = true;
            
            if (element.symbolText) {
                element.symbolText.destroy();
            }
            
            element.destroy();
            
            ElementSlicer.State.elementsSliced++;
        }
        
        /**
         * 创建切割特效
         */
        createSliceEffect(x, y, color) {
            // 创建粒子爆发效果
            const particles = [];
            for (let i = 0; i < 8; i++) {
                const particle = this.add.circle(x, y, 4, color);
                const angle = (Math.PI * 2 / 8) * i;
                const speed = 200;
                
                particles.push(particle);
                
                this.tweens.add({
                    targets: particle,
                    x: x + Math.cos(angle) * 100,
                    y: y + Math.sin(angle) * 100,
                    alpha: 0,
                    scale: 0,
                    duration: 500,
                    ease: 'Power2',
                    onComplete: () => particle.destroy()
                });
            }
        }
        
        /**
         * 创建毒雾效果
         */
        createToxicFog(x, y) {
            const fog = this.add.circle(x, y, 200, 0x4CAF50, 0.3);
            fog.setDepth(100);
            
            // 扩散动画
            this.tweens.add({
                targets: fog,
                scale: 2,
                alpha: 0.1,
                duration: 3000,
                ease: 'Power2',
                onComplete: () => fog.destroy()
            });
            
            // 遮挡玩家视线3秒
            const fogOverlay = this.add.rectangle(400, 300, 800, 600, 0x4CAF50, 0.2);
            fogOverlay.setDepth(99);
            
            this.time.delayedCall(3000, () => {
                this.tweens.add({
                    targets: fogOverlay,
                    alpha: 0,
                    duration: 500,
                    onComplete: () => fogOverlay.destroy()
                });
            });
        }
        
        /**
         * 创建幻影击中效果
         */
        createPhantomHitEffect(element) {
            // 创建波纹效果
            const ring = this.add.circle(element.x, element.y, 40, 0x00BCD4, 0);
            ring.setStrokeStyle(3, 0x00BCD4);
            
            this.tweens.add({
                targets: ring,
                scale: 1.5,
                alpha: 0,
                duration: 300,
                onComplete: () => ring.destroy()
            });
            
            // 元素闪白
            element.setTint(0xFFFFFF);
            this.time.delayedCall(100, () => element.clearTint());
        }
        
        /**
         * 创建幻影消散效果
         */
        createPhantomDestroyEffect(x, y) {
            // 创建多个幻影残像
            for (let i = 0; i < 3; i++) {
                const ghost = this.add.circle(x, y, 40, 0x00BCD4, 0.3);
                
                this.tweens.add({
                    targets: ghost,
                    x: x + ElementSlicer.Utils.random(-100, 100),
                    y: y + ElementSlicer.Utils.random(-100, 100),
                    alpha: 0,
                    scale: 0.5,
                    duration: 600,
                    delay: i * 100,
                    onComplete: () => ghost.destroy()
                });
            }
        }
        
        /**
         * 创建爆炸效果
         */
        createExplosion(x, y) {
            // 创建爆炸圆圈
            const explosion = this.add.circle(x, y, 20, 0xFF4444);
            explosion.setDepth(101);
            
            this.tweens.add({
                targets: explosion,
                scale: 5,
                alpha: 0,
                duration: 400,
                ease: 'Power2',
                onComplete: () => explosion.destroy()
            });
            
            // 创建火花粒子
            for (let i = 0; i < 12; i++) {
                const spark = this.add.circle(x, y, 3, 0xFFAA00);
                const angle = (Math.PI * 2 / 12) * i;
                const speed = ElementSlicer.Utils.random(200, 400);
                
                this.tweens.add({
                    targets: spark,
                    x: x + Math.cos(angle) * speed * 0.5,
                    y: y + Math.sin(angle) * speed * 0.5,
                    alpha: 0,
                    duration: 600,
                    ease: 'Power2',
                    onComplete: () => spark.destroy()
                });
            }
        }
        
        /**
         * 显示漂浮文字
         */
        showFloatingText(x, y, text, color) {
            const floatingText = this.add.text(x, y, text, {
                fontSize: '24px',
                fontFamily: 'Arial',
                color: color,
                stroke: '#000000',
                strokeThickness: 3
            }).setOrigin(0.5);
            
            this.tweens.add({
                targets: floatingText,
                y: y - 80,
                alpha: 0,
                duration: 1200,
                ease: 'Power2',
                onComplete: () => floatingText.destroy()
            });
        }
        
        /**
         * 更新分数显示
         */
        updateScore() {
            this.scoreText.setText(`分数: ${ElementSlicer.State.score}`);
            
            // 检查是否达到目标
            if (ElementSlicer.State.score >= ElementSlicer.Config.game.targetScore) {
                this.gameWin();
            }
        }
        
        /**
         * 显示得分弹出动画
         */
        showScorePopup(x, y, score) {
            const popup = this.add.text(x, y, `+${score}`, {
                fontSize: '28px',
                fontFamily: 'Arial',
                color: '#FFD700',
                stroke: '#000000',
                strokeThickness: 3
            }).setOrigin(0.5);
            
            // 向上飘动并淡出
            this.tweens.add({
                targets: popup,
                y: y - 50,
                alpha: 0,
                duration: 1000,
                ease: 'Power2',
                onComplete: () => {
                    popup.destroy();
                }
            });
        }
        
        /**
         * 更新连击
         */
        updateCombo() {
            ElementSlicer.State.combo++;
            
            if (ElementSlicer.State.combo > ElementSlicer.State.maxCombo) {
                ElementSlicer.State.maxCombo = ElementSlicer.State.combo;
            }
            
            // 显示连击
            if (ElementSlicer.State.combo >= 3) {
                this.showCombo();
            }
            
            // 重置连击计时器
            if (this.comboTimer) {
                this.comboTimer.remove();
            }
            
            this.comboTimer = this.time.delayedCall(2000, () => {
                ElementSlicer.State.combo = 0;
                this.hideCombo();
            });
        }
        
        /**
         * 显示连击
         */
        showCombo() {
            this.comboText.setText(`${ElementSlicer.State.combo} 连击!`);
            this.comboText.setAlpha(1);
            
            // 缩放动画
            this.tweens.add({
                targets: this.comboText,
                scaleX: 1.2,
                scaleY: 1.2,
                duration: 200,
                yoyo: true,
                ease: 'Power2'
            });
        }
        
        /**
         * 隐藏连击
         */
        hideCombo() {
            this.tweens.add({
                targets: this.comboText,
                alpha: 0,
                duration: 300
            });
        }
        
        /**
         * 切换暂停
         */
        togglePause() {
            if (ElementSlicer.State.gameState === 'playing') {
                ElementSlicer.State.gameState = 'paused';
                this.physics.pause();
                this.spawnTimer.paused = true;
                
                // 显示暂停提示
                this.pauseText = this.add.text(400, 300, '游戏暂停', {
                    fontSize: '48px',
                    fontFamily: 'Arial',
                    color: '#FFFFFF',
                    stroke: '#000000',
                    strokeThickness: 6
                }).setOrigin(0.5);
                
            } else if (ElementSlicer.State.gameState === 'paused') {
                ElementSlicer.State.gameState = 'playing';
                this.physics.resume();
                this.spawnTimer.paused = false;
                
                if (this.pauseText) {
                    this.pauseText.destroy();
                }
            }
        }
        
        /**
         * 更新生命值显示
         */
        updateLives() {
            const hearts = '❤️'.repeat(Math.max(0, ElementSlicer.State.lives));
            const lostHearts = '💔'.repeat(Math.max(0, 3 - ElementSlicer.State.lives));
            this.livesText.setText(`生命: ${hearts}${lostHearts}`);
            
            // 生命值减少时闪烁效果
            this.tweens.add({
                targets: this.livesText,
                alpha: 0.3,
                duration: 200,
                yoyo: true,
                repeat: 2
            });
        }
        
        /**
         * 游戏结束
         */
        gameOver() {
            ElementSlicer.State.gameState = 'gameover';
            this.physics.pause();
            if (this.spawnTimer) this.spawnTimer.remove();
            
            // 创建半透明黑色遮罩
            const overlay = this.add.rectangle(400, 300, 800, 600, 0x000000, 0.7);
            overlay.setDepth(200);
            
            // 游戏结束文字
            const gameOverText = this.add.text(400, 250, '游戏结束', {
                fontSize: '64px',
                fontFamily: 'Arial',
                color: '#FF4444',
                stroke: '#000000',
                strokeThickness: 6
            }).setOrigin(0.5).setDepth(201);
            
            // 最终分数
            const finalScoreText = this.add.text(400, 330, `最终分数: ${ElementSlicer.State.score}`, {
                fontSize: '32px',
                fontFamily: 'Arial',
                color: '#FFFFFF',
                stroke: '#000000',
                strokeThickness: 4
            }).setOrigin(0.5).setDepth(201);
            
            // 重新开始按钮
            const restartButton = this.add.text(400, 400, '点击重新开始', {
                fontSize: '28px',
                fontFamily: 'Arial',
                color: '#FFD700',
                stroke: '#000000',
                strokeThickness: 4
            }).setOrigin(0.5).setDepth(201).setInteractive();
            
            restartButton.on('pointerover', () => {
                restartButton.setScale(1.1);
            });
            
            restartButton.on('pointerout', () => {
                restartButton.setScale(1);
            });
            
            restartButton.on('pointerdown', () => {
                this.scene.restart();
            });
            
            ElementSlicer.DevLog.log('GAME_OVER', {
                score: ElementSlicer.State.score,
                lives: ElementSlicer.State.lives,
                maxCombo: ElementSlicer.State.maxCombo
            });
        }
        
        /**
         * 游戏胜利
         */
        gameWin() {
            ElementSlicer.State.gameState = 'gameover';
            this.physics.pause();
            if (this.spawnTimer) this.spawnTimer.remove();
            
            // 创建半透明金色遮罩
            const overlay = this.add.rectangle(400, 300, 800, 600, 0xFFD700, 0.3);
            overlay.setDepth(200);
            
            // 胜利文字
            const winText = this.add.text(400, 250, '游戏胜利!', {
                fontSize: '64px',
                fontFamily: 'Arial',
                color: '#FFD700',
                stroke: '#000000',
                strokeThickness: 6
            }).setOrigin(0.5).setDepth(201);
            
            // 星星动画
            this.createVictoryStars();
            
            // 最终分数
            const finalScoreText = this.add.text(400, 330, `最终分数: ${ElementSlicer.State.score}`, {
                fontSize: '32px',
                fontFamily: 'Arial',
                color: '#FFFFFF',
                stroke: '#000000',
                strokeThickness: 4
            }).setOrigin(0.5).setDepth(201);
            
            // 重新开始按钮
            const restartButton = this.add.text(400, 400, '再玩一次', {
                fontSize: '28px',
                fontFamily: 'Arial',
                color: '#4A90E2',
                stroke: '#000000',
                strokeThickness: 4
            }).setOrigin(0.5).setDepth(201).setInteractive();
            
            restartButton.on('pointerover', () => {
                restartButton.setScale(1.1);
            });
            
            restartButton.on('pointerout', () => {
                restartButton.setScale(1);
            });
            
            restartButton.on('pointerdown', () => {
                this.scene.restart();
            });
            
            ElementSlicer.DevLog.log('GAME_WON', {
                score: ElementSlicer.State.score,
                maxCombo: ElementSlicer.State.maxCombo
            });
        }
        
        /**
         * 创建胜利星星效果
         */
        createVictoryStars() {
            for (let i = 0; i < 20; i++) {
                const x = ElementSlicer.Utils.random(0, 800);
                const y = ElementSlicer.Utils.random(0, 600);
                const star = this.add.star(x, y, 5, 10, 20, 0xFFD700);
                star.setDepth(202);
                
                this.tweens.add({
                    targets: star,
                    scale: { from: 0, to: 1 },
                    rotation: { from: 0, to: Math.PI * 2 },
                    alpha: { from: 1, to: 0 },
                    duration: 2000,
                    delay: i * 100,
                    ease: 'Power2',
                    onComplete: () => star.destroy()
                });
            }
        }
        
        /**
         * 更新循环
         */
        update(time, delta) {
            if (ElementSlicer.State.gameState !== 'playing') return;
            
            // 更新元素
            this.elements.children.entries.forEach(element => {
                if (!element || !element.active) return;
                
                // 旋转元素
                element.rotation += ElementSlicer.Config.elements.rotationSpeed * delta / 1000;
                
                // 更新文本位置
                if (element.symbolText) {
                    element.symbolText.x = element.x;
                    element.symbolText.y = element.y;
                }
                
                // 移除超出屏幕的元素
                if (element.y < -100 || element.y > 700 || 
                    element.x < -100 || element.x > 900) {
                    this.destroyElement(element);
                }
            });
            
            // 限制场景中的元素数量
            if (this.elements.children.entries.length > 20) {
                console.warn('Too many elements:', this.elements.children.entries.length);
                // 移除最老的元素
                const oldElements = this.elements.children.entries.slice(0, -20);
                oldElements.forEach(element => {
                    if (element && element.active) {
                        this.destroyElement(element);
                    }
                });
            }
            
            // 动态调整难度
            this.updateDifficulty();
        }
        
        /**
         * 更新难度
         */
        updateDifficulty() {
            // 每30秒增加难度
            const elapsedTime = this.time.now / 1000; // 转换为秒
            const difficultyLevel = Math.floor(elapsedTime / 30);
            
            if (difficultyLevel > ElementSlicer.State.level - 1) {
                ElementSlicer.State.level = difficultyLevel + 1;
                
                // 减少生成间隔
                const newInterval = Math.max(
                    ElementSlicer.Config.game.minSpawnInterval,
                    ElementSlicer.Config.game.spawnInterval - (difficultyLevel * 200)
                );
                
                if (newInterval !== ElementSlicer.State.currentSpawnInterval) {
                    ElementSlicer.State.currentSpawnInterval = newInterval;
                    
                    // 重新设置生成定时器
                    if (this.spawnTimer) {
                        this.spawnTimer.remove();
                    }
                    
                    this.spawnTimer = this.time.addEvent({
                        delay: newInterval,
                        callback: this.spawnElement,
                        callbackScope: this,
                        loop: true
                    });
                    
                    ElementSlicer.DevLog.log('DIFFICULTY_INCREASED', {
                        level: ElementSlicer.State.level,
                        spawnInterval: newInterval
                    });
                }
            }
        }
    }
    
    // ==================== 游戏初始化 ====================
    window.addEventListener('load', () => {
        // Phaser 游戏配置
        const config = {
            type: Phaser.AUTO,
            width: ElementSlicer.Config.canvas.width,
            height: ElementSlicer.Config.canvas.height,
            parent: 'game-container',
            backgroundColor: '#1a1a2e',
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            },
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: GameScene,
            
            // 移动端优化
            input: {
                activePointers: 3  // 支持多点触控
            }
        };
        
        // 创建游戏实例
        const game = new Phaser.Game(config);
        
        // 保存游戏实例引用
        ElementSlicer.gameInstance = game;
        
        // 调试命令
        window.ElementSlicer = ElementSlicer;
        
        // 添加调试功能
        ElementSlicer.debug = {
            // 显示当前状态
            showState: () => console.table(ElementSlicer.State),
            
            // 设置分数
            setScore: (score) => {
                ElementSlicer.State.score = score;
                const scene = game.scene.getScene('GameScene');
                if (scene) scene.updateScore();
            },
            
            // 添加生命
            addLife: () => {
                ElementSlicer.State.lives++;
                console.log('生命值:', ElementSlicer.State.lives);
            },
            
            // 显示FPS
            showFPS: () => {
                game.config.fps = {
                    target: 60,
                    forceSetTimeOut: true,
                    showFPS: true
                };
            },
            
            // 清理所有元素
            clearAllElements: () => {
                const scene = game.scene.getScene('GameScene');
                if (scene && scene.elements) {
                    scene.elements.children.entries.forEach(element => {
                        if (element) {
                            if (element.symbolText) {
                                element.symbolText.destroy();
                            }
                            element.destroy();
                        }
                    });
                    console.log('已清理所有元素');
                }
            },
            
            // 重启游戏
            restart: () => {
                const scene = game.scene.getScene('GameScene');
                if (scene) {
                    scene.scene.restart();
                }
            },
            
            // 创建测试元素
            createTestElement: () => {
                const scene = game.scene.getScene('GameScene');
                if (scene) {
                    // 创建一个简单的红色矩形作为测试
                    const testElement = scene.add.rectangle(400, 300, 80, 80, 0xFF0000);
                    scene.physics.add.existing(testElement);
                    testElement.body.setVelocity(0, -200);
                    testElement.body.setGravity(0, 300);
                    console.log('创建了测试元素（红色方块）');
                }
            }
        };
        
        ElementSlicer.DevLog.log('GAME_INITIALIZED', '游戏初始化完成');
    });
    </script>
</body>
</html>