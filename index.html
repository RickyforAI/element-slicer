<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å…ƒç´ åˆ‡åˆ‡ä¹ - Element Slicer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            max-width: 100vw;
            max-height: 100vh;
        }
        
        #game-canvas {
            border: 2px solid #16213e;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(94, 84, 142, 0.5);
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 24px;
            text-align: center;
        }
        
        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-left: 10px;
            border: 3px solid #fff;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div class="loading" id="loading">åŠ è½½ä¸­</div>
    </div>
    
    <!-- å¼•å…¥ Phaser 3.70.0 -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    
    <script>
    // ==================== æ¸¸æˆæ¶æ„ ====================
    const ElementSlicer = {
        // é…ç½®ç³»ç»Ÿ - æ‰€æœ‰å¯è°ƒå‚æ•°é›†ä¸­ç®¡ç†
        Config: {
            canvas: {
                width: 800,
                height: 600
            },
            
            // æ¸¸æˆé…ç½®
            game: {
                targetScore: 300,       // ç›®æ ‡åˆ†æ•°
                initialLives: 3,        // åˆå§‹ç”Ÿå‘½å€¼
                spawnInterval: 2000,    // åˆå§‹ç”Ÿæˆé—´éš”ï¼ˆæ¯«ç§’ï¼‰
                minSpawnInterval: 1000, // æœ€å°ç”Ÿæˆé—´éš”
                gravity: 300            // é‡åŠ›å€¼
            },
            
            // å…ƒç´ é…ç½®
            elements: {
                radius: 40,             // å…ƒç´ åŠå¾„
                initialVelocityY: -400, // åˆå§‹å‘ä¸Šé€Ÿåº¦
                rotationSpeed: 2,       // æ—‹è½¬é€Ÿåº¦
                
                // å…ƒç´ ç±»å‹å®šä¹‰
                types: {
                    normal: {
                        symbols: ['C', 'N', 'O', 'H'],
                        color: 0x4A90E2,    // è“è‰²
                        score: 5,
                        name: 'æ™®é€šå…ƒç´ '
                    },
                    toxic: {
                        symbols: ['F', 'Cl', 'Br'],
                        color: 0x4CAF50,    // ç»¿è‰²
                        score: 8,
                        name: 'æ¯’é›¾å…ƒç´ '
                    },
                    phantom: {
                        symbols: ['He', 'Ne', 'Ar'],
                        color: 0x00BCD4,    // é’è‰²
                        score: 15,
                        health: 3,          // éœ€è¦åˆ‡3æ¬¡
                        name: 'å¹»å½±å…ƒç´ '
                    },
                    explosive: {
                        symbols: ['Li', 'Na', 'K'],
                        color: 0xFF4444,    // çº¢è‰²
                        score: 0,
                        damage: 1,          // æ‰£é™¤ç”Ÿå‘½å€¼
                        name: 'çˆ†è£‚å…ƒç´ '
                    }
                }
            },
            
            // UIé…ç½®
            ui: {
                fontSize: 24,
                fontFamily: 'Arial',
                colors: {
                    text: '#FFFFFF',
                    score: '#FFD700',
                    lives: '#FF6B6B'
                }
            },
            
            // ç‰ˆæœ¬ä¿¡æ¯
            version: '0.2.0'
        },
        
        // æ¸¸æˆçŠ¶æ€ - å…¨å±€çŠ¶æ€ç®¡ç†
        State: {
            gameState: 'loading',   // loading, menu, playing, paused, gameover
            score: 0,
            lives: 3,
            combo: 0,
            maxCombo: 0,
            level: 1,
            elementsSpawned: 0,
            elementsSliced: 0,
            currentSpawnInterval: 2000
        },
        
        // æ ¸å¿ƒç³»ç»Ÿ
        Systems: {},
        
        // å·¥å…·å‡½æ•°
        Utils: {
            /**
             * ç”ŸæˆæŒ‡å®šèŒƒå›´çš„éšæœºæ•°
             */
            random: function(min, max) {
                return Math.random() * (max - min) + min;
            },
            
            /**
             * è®¡ç®—ä¸¤ç‚¹ä¹‹é—´çš„è·ç¦»
             */
            distance: function(x1, y1, x2, y2) {
                const dx = x2 - x1;
                const dy = y2 - y1;
                return Math.sqrt(dx * dx + dy * dy);
            },
            
            /**
             * çº¿æ€§æ’å€¼
             */
            lerp: function(a, b, t) {
                return a + (b - a) * t;
            }
        },
        
        // å¼€å‘æ—¥å¿—
        DevLog: {
            entries: [],
            
            log: function(action, details) {
                this.entries.push({
                    timestamp: new Date().toISOString(),
                    action: action,
                    details: details,
                    version: ElementSlicer.Config.version
                });
                console.log(`[DevLog] ${action}:`, details);
            }
        }
    };
    
    // ==================== Phaser åœºæ™¯å®šä¹‰ ====================
    class GameScene extends Phaser.Scene {
        constructor() {
            super({ key: 'GameScene' });
            
            // åœºæ™¯å˜é‡
            this.elements = null;       // å…ƒç´ ç»„
            this.sliceGraphics = null;  // åˆ‡å‰²è½¨è¿¹
            this.scoreText = null;      // åˆ†æ•°æ–‡æœ¬
            this.livesText = null;      // ç”Ÿå‘½å€¼æ–‡æœ¬
            this.comboText = null;      // è¿å‡»æ–‡æœ¬
            this.background = null;     // èƒŒæ™¯
            
            // åˆ‡å‰²ç›¸å…³
            this.isSlicing = false;
            this.slicePoints = [];
            
            // ç”Ÿæˆå®šæ—¶å™¨
            this.spawnTimer = null;
        }
        
        /**
         * é¢„åŠ è½½èµ„æº
         */
        preload() {
            // åˆ›å»ºåŠ è½½è¿›åº¦æ¡
            const progressBar = this.add.graphics();
            const progressBox = this.add.graphics();
            progressBox.fillStyle(0x222222, 0.8);
            progressBox.fillRect(240, 270, 320, 50);
            
            const width = this.cameras.main.width;
            const height = this.cameras.main.height;
            const loadingText = this.make.text({
                x: width / 2,
                y: height / 2 - 50,
                text: 'åŠ è½½ä¸­...',
                style: {
                    font: '20px Arial',
                    fill: '#ffffff'
                }
            });
            loadingText.setOrigin(0.5, 0.5);
            
            // ç›‘å¬åŠ è½½è¿›åº¦
            this.load.on('progress', function (value) {
                progressBar.clear();
                progressBar.fillStyle(0xffffff, 1);
                progressBar.fillRect(250, 280, 300 * value, 30);
            });
            
            // åŠ è½½å®Œæˆ
            this.load.on('complete', function () {
                progressBar.destroy();
                progressBox.destroy();
                loadingText.destroy();
                ElementSlicer.DevLog.log('ASSETS_LOADED', 'èµ„æºåŠ è½½å®Œæˆ');
            });
            
            // åŠ¨æ€åˆ›å»ºåœ†å½¢çº¹ç†
            this.load.on('start', () => {
                // åˆ›å»ºä¸åŒé¢œè‰²çš„åœ†å½¢çº¹ç†
                const colors = {
                    'normal': 0x4A90E2,
                    'toxic': 0x4CAF50,
                    'phantom': 0x00BCD4,
                    'explosive': 0xFF4444
                };
                
                for (let type in colors) {
                    const graphics = this.make.graphics({ x: 0, y: 0 });
                    graphics.fillStyle(colors[type], 1);
                    graphics.fillCircle(40, 40, 40);
                    graphics.generateTexture('element_' + type, 80, 80);
                    graphics.destroy();
                }
            });
            
            this.load.start();
        }
        
        /**
         * åˆ›å»ºæ¸¸æˆåœºæ™¯
         */
        create() {
            ElementSlicer.DevLog.log('SCENE_CREATED', 'æ¸¸æˆåœºæ™¯åˆ›å»º');
            
            // éšè—åŠ è½½æç¤º
            document.getElementById('loading').style.display = 'none';
            
            // åˆ›å»ºç´«è‰²æ¸å˜èƒŒæ™¯
            this.createBackground();
            
            // åˆ›å»ºUI
            this.createUI();
            
            // åˆ›å»ºå…ƒç´ ç»„
            this.elements = this.physics.add.group();
            
            // åˆ›å»ºåˆ‡å‰²è½¨è¿¹å›¾å½¢
            this.sliceGraphics = this.add.graphics();
            
            // è®¾ç½®è¾“å…¥äº‹ä»¶
            this.setupInput();
            
            // å¼€å§‹æ¸¸æˆ
            this.startGame();
        }
        
        /**
         * åˆ›å»ºèƒŒæ™¯
         */
        createBackground() {
            // åˆ›å»ºæ¸å˜èƒŒæ™¯
            const graphics = this.add.graphics();
            
            // æ·±ç´«åˆ°æµ…ç´«çš„æ¸å˜
            const color1 = 0x1a1a2e;  // æ·±ç´«
            const color2 = 0x16213e;  // ä¸­ç´«
            const color3 = 0x0f3460;  // æµ…ç´«
            
            // ç»˜åˆ¶æ¸å˜çŸ©å½¢
            for (let i = 0; i < 100; i++) {
                const color = Phaser.Display.Color.Interpolate.ColorWithColor(
                    Phaser.Display.Color.ValueToColor(color1),
                    Phaser.Display.Color.ValueToColor(color3),
                    100,
                    i
                );
                graphics.fillStyle(color.color, 1);
                graphics.fillRect(0, i * 6, 800, 6);
            }
            
            this.background = graphics;
        }
        
        /**
         * åˆ›å»ºUIç•Œé¢
         */
        createUI() {
            const config = ElementSlicer.Config;
            
            // æ¸¸æˆæ ‡é¢˜
            this.add.text(config.canvas.width / 2, 30, 'å…ƒç´ åˆ‡åˆ‡ä¹', {
                fontSize: '36px',
                fontFamily: config.ui.fontFamily,
                color: config.ui.colors.text,
                stroke: '#000000',
                strokeThickness: 4
            }).setOrigin(0.5);
            
            // åˆ†æ•°æ˜¾ç¤º
            this.scoreText = this.add.text(20, 20, 'åˆ†æ•°: 0', {
                fontSize: config.ui.fontSize + 'px',
                fontFamily: config.ui.fontFamily,
                color: config.ui.colors.score
            });
            
            // ç”Ÿå‘½å€¼æ˜¾ç¤º
            this.livesText = this.add.text(20, 60, 'ç”Ÿå‘½: â¤ï¸â¤ï¸â¤ï¸', {
                fontSize: config.ui.fontSize + 'px',
                fontFamily: config.ui.fontFamily,
                color: config.ui.colors.lives
            });
            
            // è¿å‡»æ˜¾ç¤ºï¼ˆåˆå§‹éšè—ï¼‰
            this.comboText = this.add.text(config.canvas.width / 2, 100, '', {
                fontSize: '32px',
                fontFamily: config.ui.fontFamily,
                color: '#FFD700',
                stroke: '#000000',
                strokeThickness: 4
            }).setOrigin(0.5).setAlpha(0);
            
            // ç›®æ ‡åˆ†æ•°æç¤º
            this.add.text(config.canvas.width - 20, 20, 
                `ç›®æ ‡: ${config.game.targetScore}åˆ†`, {
                fontSize: '20px',
                fontFamily: config.ui.fontFamily,
                color: '#FFFFFF',
                align: 'right'
            }).setOrigin(1, 0);
        }
        
        /**
         * è®¾ç½®è¾“å…¥äº‹ä»¶
         */
        setupInput() {
            // é¼ æ ‡/è§¦æ‘¸å¼€å§‹
            this.input.on('pointerdown', (pointer) => {
                this.startSlice(pointer);
            });
            
            // é¼ æ ‡/è§¦æ‘¸ç§»åŠ¨
            this.input.on('pointermove', (pointer) => {
                if (this.isSlicing) {
                    this.updateSlice(pointer);
                }
            });
            
            // é¼ æ ‡/è§¦æ‘¸ç»“æŸ
            this.input.on('pointerup', () => {
                this.endSlice();
            });
            
            // é”®ç›˜äº‹ä»¶ï¼ˆè°ƒè¯•ç”¨ï¼‰
            this.input.keyboard.on('keydown-P', () => {
                this.togglePause();
            });
        }
        
        /**
         * å¼€å§‹æ¸¸æˆ
         */
        startGame() {
            ElementSlicer.State.gameState = 'playing';
            ElementSlicer.State.score = 0;
            ElementSlicer.State.lives = ElementSlicer.Config.game.initialLives;
            ElementSlicer.State.combo = 0;
            
            // å¼€å§‹ç”Ÿæˆå…ƒç´ 
            this.startElementSpawning();
            
            ElementSlicer.DevLog.log('GAME_STARTED', 'æ¸¸æˆå¼€å§‹');
        }
        
        /**
         * å¼€å§‹ç”Ÿæˆå…ƒç´ 
         */
        startElementSpawning() {
            // ç«‹å³ç”Ÿæˆç¬¬ä¸€ä¸ªå…ƒç´ 
            this.spawnElement();
            
            // è®¾ç½®å®šæ—¶ç”Ÿæˆ
            this.spawnTimer = this.time.addEvent({
                delay: ElementSlicer.State.currentSpawnInterval,
                callback: this.spawnElement,
                callbackScope: this,
                loop: true
            });
        }
        
        /**
         * ç”Ÿæˆå…ƒç´ 
         */
        spawnElement() {
            // éšæœºé€‰æ‹©å…ƒç´ ç±»å‹
            const types = ['normal', 'toxic', 'phantom', 'explosive'];
            const weights = [0.5, 0.2, 0.15, 0.15]; // æ™®é€šå…ƒç´ å‡ºç°æ¦‚ç‡æ›´é«˜
            
            // æ ¹æ®æƒé‡é€‰æ‹©ç±»å‹
            let random = Math.random();
            let typeIndex = 0;
            let sum = 0;
            for (let i = 0; i < weights.length; i++) {
                sum += weights[i];
                if (random < sum) {
                    typeIndex = i;
                    break;
                }
            }
            
            const elementType = types[typeIndex];
            const typeConfig = ElementSlicer.Config.elements.types[elementType];
            
            // éšæœºé€‰æ‹©è¯¥ç±»å‹çš„ä¸€ä¸ªç¬¦å·
            const symbol = typeConfig.symbols[Math.floor(Math.random() * typeConfig.symbols.length)];
            
            const x = ElementSlicer.Utils.random(100, 700);
            const y = 650; // ä»å±å¹•åº•éƒ¨ä¸‹æ–¹å¼€å§‹
            
            // ä½¿ç”¨é¢„åŠ è½½çš„çº¹ç†åˆ›å»ºå…ƒç´ 
            const element = this.physics.add.image(x, y, 'element_' + elementType);
            element.setDisplaySize(80, 80);
            element.body.setVelocity(
                ElementSlicer.Utils.random(-50, 50), // è½»å¾®çš„æ°´å¹³é€Ÿåº¦
                ElementSlicer.Config.elements.initialVelocityY
            );
            element.body.setGravity(0, ElementSlicer.Config.game.gravity);
            
            // æ·»åŠ å…ƒç´ å±æ€§
            element.elementType = elementType;
            element.symbol = symbol;
            element.score = typeConfig.score;
            element.damage = typeConfig.damage || 0;
            element.health = typeConfig.health || 1;
            element.isSliced = false;
            element.fillColor = typeConfig.color;
            
            // æ·»åŠ å…ƒç´ ç¬¦å·æ–‡æœ¬
            const symbolText = this.add.text(x, y, symbol, {
                fontSize: '28px',
                fontFamily: 'Arial',
                color: '#FFFFFF',
                stroke: '#000000',
                strokeThickness: 2
            }).setOrigin(0.5);
            
            element.symbolText = symbolText;
            
            // ä¸ºç‰¹æ®Šå…ƒç´ æ·»åŠ è§†è§‰æ•ˆæœ
            if (elementType === 'phantom') {
                // å¹»å½±å…ƒç´ ï¼šåŠé€æ˜æ•ˆæœ
                element.setAlpha(0.7);
                
                // æ·»åŠ é—ªçƒæ•ˆæœ
                this.tweens.add({
                    targets: element,
                    alpha: 0.3,
                    duration: 1000,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
            } else if (elementType === 'explosive') {
                // çˆ†è£‚å…ƒç´ ï¼šè„‰åŠ¨æ•ˆæœ
                this.tweens.add({
                    targets: element,
                    scaleX: 1.1,
                    scaleY: 1.1,
                    duration: 500,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
            }
            
            // æ·»åŠ åˆ°å…ƒç´ ç»„
            this.elements.add(element);
            
            ElementSlicer.State.elementsSpawned++;
            
            // è°ƒè¯•ä¿¡æ¯
            console.log(`ç”Ÿæˆå…ƒç´ : ${elementType} (${symbol}) at (${x}, ${y})`);
            console.log(`å…ƒç´ æ€»æ•°: ${this.elements.children.entries.length}`);
        }
        
        /**
         * å¼€å§‹åˆ‡å‰²
         */
        startSlice(pointer) {
            this.isSlicing = true;
            this.slicePoints = [{ x: pointer.x, y: pointer.y }];
        }
        
        /**
         * æ›´æ–°åˆ‡å‰²è½¨è¿¹
         */
        updateSlice(pointer) {
            if (!this.isSlicing) return;
            
            // æ·»åŠ æ–°ç‚¹
            this.slicePoints.push({ x: pointer.x, y: pointer.y });
            
            // é™åˆ¶ç‚¹æ•°é‡
            if (this.slicePoints.length > 20) {
                this.slicePoints.shift();
            }
            
            // ç»˜åˆ¶è½¨è¿¹
            this.drawSliceTrail();
            
            // æ£€æµ‹ç¢°æ’
            this.checkSliceCollision(pointer);
        }
        
        /**
         * ç»“æŸåˆ‡å‰²
         */
        endSlice() {
            this.isSlicing = false;
            this.slicePoints = [];
            this.sliceGraphics.clear();
        }
        
        /**
         * ç»˜åˆ¶åˆ‡å‰²è½¨è¿¹
         */
        drawSliceTrail() {
            this.sliceGraphics.clear();
            
            if (this.slicePoints.length < 2) return;
            
            // è®¾ç½®çº¿æ¡æ ·å¼
            this.sliceGraphics.lineStyle(4, 0xFFFFFF, 1);
            
            // ç»˜åˆ¶è½¨è¿¹
            this.sliceGraphics.beginPath();
            this.sliceGraphics.moveTo(this.slicePoints[0].x, this.slicePoints[0].y);
            
            for (let i = 1; i < this.slicePoints.length; i++) {
                const alpha = i / this.slicePoints.length;
                this.sliceGraphics.lineStyle(4, 0xFFFFFF, alpha);
                this.sliceGraphics.lineTo(this.slicePoints[i].x, this.slicePoints[i].y);
            }
            
            this.sliceGraphics.strokePath();
            
            // æ·»åŠ å‘å…‰æ•ˆæœ
            this.sliceGraphics.lineStyle(8, 0xFFFFFF, 0.3);
            this.sliceGraphics.strokePath();
        }
        
        /**
         * æ£€æµ‹åˆ‡å‰²ç¢°æ’
         */
        checkSliceCollision(pointer) {
            this.elements.children.entries.forEach(element => {
                if (!element.active) return;
                
                const distance = ElementSlicer.Utils.distance(
                    pointer.x, pointer.y,
                    element.x, element.y
                );
                
                if (distance < ElementSlicer.Config.elements.radius + 10) {
                    this.sliceElement(element);
                }
            });
        }
        
        /**
         * åˆ‡å‰²å…ƒç´ 
         */
        sliceElement(element) {
            if (element.isSliced) return; // é˜²æ­¢é‡å¤åˆ‡å‰²
            
            // æ ¹æ®å…ƒç´ ç±»å‹æ‰§è¡Œä¸åŒè¡Œä¸º
            switch (element.elementType) {
                case 'normal':
                    this.handleNormalSlice(element);
                    break;
                    
                case 'toxic':
                    this.handleToxicSlice(element);
                    break;
                    
                case 'phantom':
                    this.handlePhantomSlice(element);
                    break;
                    
                case 'explosive':
                    this.handleExplosiveSlice(element);
                    break;
            }
        }
        
        /**
         * å¤„ç†æ™®é€šå…ƒç´ åˆ‡å‰²
         */
        handleNormalSlice(element) {
            // æ›´æ–°åˆ†æ•°
            ElementSlicer.State.score += element.score;
            this.updateScore();
            
            // æ˜¾ç¤ºå¾—åˆ†åŠ¨ç”»
            this.showScorePopup(element.x, element.y, element.score);
            
            // åˆ›å»ºåˆ‡å‰²ç‰¹æ•ˆ
            this.createSliceEffect(element.x, element.y, 0x4A90E2);
            
            // ç§»é™¤å…ƒç´ 
            this.destroyElement(element);
            
            // æ›´æ–°è¿å‡»
            this.updateCombo();
        }
        
        /**
         * å¤„ç†æ¯’é›¾å…ƒç´ åˆ‡å‰²
         */
        handleToxicSlice(element) {
            // æ›´æ–°åˆ†æ•°
            ElementSlicer.State.score += element.score;
            this.updateScore();
            
            // æ˜¾ç¤ºå¾—åˆ†åŠ¨ç”»
            this.showScorePopup(element.x, element.y, element.score);
            
            // åˆ›å»ºæ¯’é›¾æ•ˆæœ
            this.createToxicFog(element.x, element.y);
            
            // ç§»é™¤å…ƒç´ 
            this.destroyElement(element);
            
            // æ›´æ–°è¿å‡»
            this.updateCombo();
        }
        
        /**
         * å¤„ç†å¹»å½±å…ƒç´ åˆ‡å‰²
         */
        handlePhantomSlice(element) {
            element.health--;
            
            if (element.health > 0) {
                // è¿˜éœ€è¦ç»§ç»­åˆ‡å‰²
                this.createPhantomHitEffect(element);
                
                // åŠ é€Ÿé€ƒè·‘
                const currentVelocity = element.body.velocity;
                element.body.setVelocity(
                    currentVelocity.x * 1.5,
                    currentVelocity.y * 1.2
                );
                
                // æ˜¾ç¤ºå‰©ä½™åˆ‡å‰²æ¬¡æ•°
                this.showFloatingText(element.x, element.y - 50, 
                    `è¿˜éœ€${element.health}æ¬¡!`, '#00BCD4');
            } else {
                // å®Œæˆåˆ‡å‰²
                ElementSlicer.State.score += element.score;
                this.updateScore();
                
                // æ˜¾ç¤ºå¾—åˆ†åŠ¨ç”»
                this.showScorePopup(element.x, element.y, element.score);
                
                // åˆ›å»ºå¹»å½±æ¶ˆæ•£æ•ˆæœ
                this.createPhantomDestroyEffect(element.x, element.y);
                
                // ç§»é™¤å…ƒç´ 
                this.destroyElement(element);
                
                // æ›´æ–°è¿å‡»
                this.updateCombo();
            }
        }
        
        /**
         * å¤„ç†çˆ†è£‚å…ƒç´ åˆ‡å‰²
         */
        handleExplosiveSlice(element) {
            // æ‰£é™¤ç”Ÿå‘½å€¼
            if (ElementSlicer.State.lives > 0) {
                ElementSlicer.State.lives--;
                this.updateLives();
            }
            
            // åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
            this.createExplosion(element.x, element.y);
            
            // å±å¹•éœ‡åŠ¨
            this.cameras.main.shake(300, 0.02);
            
            // æ˜¾ç¤ºè­¦å‘Š
            this.showFloatingText(element.x, element.y, '-1 ç”Ÿå‘½!', '#FF4444');
            
            // ç§»é™¤å…ƒç´ 
            this.destroyElement(element);
            
            // é‡ç½®è¿å‡»
            ElementSlicer.State.combo = 0;
            this.hideCombo();
            
            // æ£€æŸ¥æ¸¸æˆç»“æŸ
            if (ElementSlicer.State.lives <= 0) {
                this.gameOver();
            }
        }
        
        /**
         * é”€æ¯å…ƒç´ 
         */
        destroyElement(element) {
            element.isSliced = true;
            
            if (element.symbolText) {
                element.symbolText.destroy();
            }
            
            element.destroy();
            
            ElementSlicer.State.elementsSliced++;
        }
        
        /**
         * åˆ›å»ºåˆ‡å‰²ç‰¹æ•ˆ
         */
        createSliceEffect(x, y, color) {
            // åˆ›å»ºç²’å­çˆ†å‘æ•ˆæœ
            const particles = [];
            for (let i = 0; i < 8; i++) {
                const particle = this.add.circle(x, y, 4, color);
                const angle = (Math.PI * 2 / 8) * i;
                const speed = 200;
                
                particles.push(particle);
                
                this.tweens.add({
                    targets: particle,
                    x: x + Math.cos(angle) * 100,
                    y: y + Math.sin(angle) * 100,
                    alpha: 0,
                    scale: 0,
                    duration: 500,
                    ease: 'Power2',
                    onComplete: () => particle.destroy()
                });
            }
        }
        
        /**
         * åˆ›å»ºæ¯’é›¾æ•ˆæœ
         */
        createToxicFog(x, y) {
            const fog = this.add.circle(x, y, 200, 0x4CAF50, 0.3);
            fog.setDepth(100);
            
            // æ‰©æ•£åŠ¨ç”»
            this.tweens.add({
                targets: fog,
                scale: 2,
                alpha: 0.1,
                duration: 3000,
                ease: 'Power2',
                onComplete: () => fog.destroy()
            });
            
            // é®æŒ¡ç©å®¶è§†çº¿3ç§’
            const fogOverlay = this.add.rectangle(400, 300, 800, 600, 0x4CAF50, 0.2);
            fogOverlay.setDepth(99);
            
            this.time.delayedCall(3000, () => {
                this.tweens.add({
                    targets: fogOverlay,
                    alpha: 0,
                    duration: 500,
                    onComplete: () => fogOverlay.destroy()
                });
            });
        }
        
        /**
         * åˆ›å»ºå¹»å½±å‡»ä¸­æ•ˆæœ
         */
        createPhantomHitEffect(element) {
            // åˆ›å»ºæ³¢çº¹æ•ˆæœ
            const ring = this.add.circle(element.x, element.y, 40, 0x00BCD4, 0);
            ring.setStrokeStyle(3, 0x00BCD4);
            
            this.tweens.add({
                targets: ring,
                scale: 1.5,
                alpha: 0,
                duration: 300,
                onComplete: () => ring.destroy()
            });
            
            // å…ƒç´ é—ªç™½
            element.setTint(0xFFFFFF);
            this.time.delayedCall(100, () => element.clearTint());
        }
        
        /**
         * åˆ›å»ºå¹»å½±æ¶ˆæ•£æ•ˆæœ
         */
        createPhantomDestroyEffect(x, y) {
            // åˆ›å»ºå¤šä¸ªå¹»å½±æ®‹åƒ
            for (let i = 0; i < 3; i++) {
                const ghost = this.add.circle(x, y, 40, 0x00BCD4, 0.3);
                
                this.tweens.add({
                    targets: ghost,
                    x: x + ElementSlicer.Utils.random(-100, 100),
                    y: y + ElementSlicer.Utils.random(-100, 100),
                    alpha: 0,
                    scale: 0.5,
                    duration: 600,
                    delay: i * 100,
                    onComplete: () => ghost.destroy()
                });
            }
        }
        
        /**
         * åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
         */
        createExplosion(x, y) {
            // åˆ›å»ºçˆ†ç‚¸åœ†åœˆ
            const explosion = this.add.circle(x, y, 20, 0xFF4444);
            explosion.setDepth(101);
            
            this.tweens.add({
                targets: explosion,
                scale: 5,
                alpha: 0,
                duration: 400,
                ease: 'Power2',
                onComplete: () => explosion.destroy()
            });
            
            // åˆ›å»ºç«èŠ±ç²’å­
            for (let i = 0; i < 12; i++) {
                const spark = this.add.circle(x, y, 3, 0xFFAA00);
                const angle = (Math.PI * 2 / 12) * i;
                const speed = ElementSlicer.Utils.random(200, 400);
                
                this.tweens.add({
                    targets: spark,
                    x: x + Math.cos(angle) * speed * 0.5,
                    y: y + Math.sin(angle) * speed * 0.5,
                    alpha: 0,
                    duration: 600,
                    ease: 'Power2',
                    onComplete: () => spark.destroy()
                });
            }
        }
        
        /**
         * æ˜¾ç¤ºæ¼‚æµ®æ–‡å­—
         */
        showFloatingText(x, y, text, color) {
            const floatingText = this.add.text(x, y, text, {
                fontSize: '24px',
                fontFamily: 'Arial',
                color: color,
                stroke: '#000000',
                strokeThickness: 3
            }).setOrigin(0.5);
            
            this.tweens.add({
                targets: floatingText,
                y: y - 80,
                alpha: 0,
                duration: 1200,
                ease: 'Power2',
                onComplete: () => floatingText.destroy()
            });
        }
        
        /**
         * æ›´æ–°åˆ†æ•°æ˜¾ç¤º
         */
        updateScore() {
            this.scoreText.setText(`åˆ†æ•°: ${ElementSlicer.State.score}`);
            
            // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°ç›®æ ‡
            if (ElementSlicer.State.score >= ElementSlicer.Config.game.targetScore) {
                this.gameWin();
            }
        }
        
        /**
         * æ˜¾ç¤ºå¾—åˆ†å¼¹å‡ºåŠ¨ç”»
         */
        showScorePopup(x, y, score) {
            const popup = this.add.text(x, y, `+${score}`, {
                fontSize: '28px',
                fontFamily: 'Arial',
                color: '#FFD700',
                stroke: '#000000',
                strokeThickness: 3
            }).setOrigin(0.5);
            
            // å‘ä¸Šé£˜åŠ¨å¹¶æ·¡å‡º
            this.tweens.add({
                targets: popup,
                y: y - 50,
                alpha: 0,
                duration: 1000,
                ease: 'Power2',
                onComplete: () => {
                    popup.destroy();
                }
            });
        }
        
        /**
         * æ›´æ–°è¿å‡»
         */
        updateCombo() {
            ElementSlicer.State.combo++;
            
            if (ElementSlicer.State.combo > ElementSlicer.State.maxCombo) {
                ElementSlicer.State.maxCombo = ElementSlicer.State.combo;
            }
            
            // æ˜¾ç¤ºè¿å‡»
            if (ElementSlicer.State.combo >= 3) {
                this.showCombo();
            }
            
            // é‡ç½®è¿å‡»è®¡æ—¶å™¨
            if (this.comboTimer) {
                this.comboTimer.remove();
            }
            
            this.comboTimer = this.time.delayedCall(2000, () => {
                ElementSlicer.State.combo = 0;
                this.hideCombo();
            });
        }
        
        /**
         * æ˜¾ç¤ºè¿å‡»
         */
        showCombo() {
            this.comboText.setText(`${ElementSlicer.State.combo} è¿å‡»!`);
            this.comboText.setAlpha(1);
            
            // ç¼©æ”¾åŠ¨ç”»
            this.tweens.add({
                targets: this.comboText,
                scaleX: 1.2,
                scaleY: 1.2,
                duration: 200,
                yoyo: true,
                ease: 'Power2'
            });
        }
        
        /**
         * éšè—è¿å‡»
         */
        hideCombo() {
            this.tweens.add({
                targets: this.comboText,
                alpha: 0,
                duration: 300
            });
        }
        
        /**
         * åˆ‡æ¢æš‚åœ
         */
        togglePause() {
            if (ElementSlicer.State.gameState === 'playing') {
                ElementSlicer.State.gameState = 'paused';
                this.physics.pause();
                this.spawnTimer.paused = true;
                
                // æ˜¾ç¤ºæš‚åœæç¤º
                this.pauseText = this.add.text(400, 300, 'æ¸¸æˆæš‚åœ', {
                    fontSize: '48px',
                    fontFamily: 'Arial',
                    color: '#FFFFFF',
                    stroke: '#000000',
                    strokeThickness: 6
                }).setOrigin(0.5);
                
            } else if (ElementSlicer.State.gameState === 'paused') {
                ElementSlicer.State.gameState = 'playing';
                this.physics.resume();
                this.spawnTimer.paused = false;
                
                if (this.pauseText) {
                    this.pauseText.destroy();
                }
            }
        }
        
        /**
         * æ›´æ–°ç”Ÿå‘½å€¼æ˜¾ç¤º
         */
        updateLives() {
            const hearts = 'â¤ï¸'.repeat(Math.max(0, ElementSlicer.State.lives));
            const lostHearts = 'ğŸ’”'.repeat(Math.max(0, 3 - ElementSlicer.State.lives));
            this.livesText.setText(`ç”Ÿå‘½: ${hearts}${lostHearts}`);
            
            // ç”Ÿå‘½å€¼å‡å°‘æ—¶é—ªçƒæ•ˆæœ
            this.tweens.add({
                targets: this.livesText,
                alpha: 0.3,
                duration: 200,
                yoyo: true,
                repeat: 2
            });
        }
        
        /**
         * æ¸¸æˆç»“æŸ
         */
        gameOver() {
            ElementSlicer.State.gameState = 'gameover';
            this.physics.pause();
            if (this.spawnTimer) this.spawnTimer.remove();
            
            // åˆ›å»ºåŠé€æ˜é»‘è‰²é®ç½©
            const overlay = this.add.rectangle(400, 300, 800, 600, 0x000000, 0.7);
            overlay.setDepth(200);
            
            // æ¸¸æˆç»“æŸæ–‡å­—
            const gameOverText = this.add.text(400, 250, 'æ¸¸æˆç»“æŸ', {
                fontSize: '64px',
                fontFamily: 'Arial',
                color: '#FF4444',
                stroke: '#000000',
                strokeThickness: 6
            }).setOrigin(0.5).setDepth(201);
            
            // æœ€ç»ˆåˆ†æ•°
            const finalScoreText = this.add.text(400, 330, `æœ€ç»ˆåˆ†æ•°: ${ElementSlicer.State.score}`, {
                fontSize: '32px',
                fontFamily: 'Arial',
                color: '#FFFFFF',
                stroke: '#000000',
                strokeThickness: 4
            }).setOrigin(0.5).setDepth(201);
            
            // é‡æ–°å¼€å§‹æŒ‰é’®
            const restartButton = this.add.text(400, 400, 'ç‚¹å‡»é‡æ–°å¼€å§‹', {
                fontSize: '28px',
                fontFamily: 'Arial',
                color: '#FFD700',
                stroke: '#000000',
                strokeThickness: 4
            }).setOrigin(0.5).setDepth(201).setInteractive();
            
            restartButton.on('pointerover', () => {
                restartButton.setScale(1.1);
            });
            
            restartButton.on('pointerout', () => {
                restartButton.setScale(1);
            });
            
            restartButton.on('pointerdown', () => {
                this.scene.restart();
            });
            
            ElementSlicer.DevLog.log('GAME_OVER', {
                score: ElementSlicer.State.score,
                lives: ElementSlicer.State.lives,
                maxCombo: ElementSlicer.State.maxCombo
            });
        }
        
        /**
         * æ¸¸æˆèƒœåˆ©
         */
        gameWin() {
            ElementSlicer.State.gameState = 'gameover';
            this.physics.pause();
            if (this.spawnTimer) this.spawnTimer.remove();
            
            // åˆ›å»ºåŠé€æ˜é‡‘è‰²é®ç½©
            const overlay = this.add.rectangle(400, 300, 800, 600, 0xFFD700, 0.3);
            overlay.setDepth(200);
            
            // èƒœåˆ©æ–‡å­—
            const winText = this.add.text(400, 250, 'æ¸¸æˆèƒœåˆ©!', {
                fontSize: '64px',
                fontFamily: 'Arial',
                color: '#FFD700',
                stroke: '#000000',
                strokeThickness: 6
            }).setOrigin(0.5).setDepth(201);
            
            // æ˜Ÿæ˜ŸåŠ¨ç”»
            this.createVictoryStars();
            
            // æœ€ç»ˆåˆ†æ•°
            const finalScoreText = this.add.text(400, 330, `æœ€ç»ˆåˆ†æ•°: ${ElementSlicer.State.score}`, {
                fontSize: '32px',
                fontFamily: 'Arial',
                color: '#FFFFFF',
                stroke: '#000000',
                strokeThickness: 4
            }).setOrigin(0.5).setDepth(201);
            
            // é‡æ–°å¼€å§‹æŒ‰é’®
            const restartButton = this.add.text(400, 400, 'å†ç©ä¸€æ¬¡', {
                fontSize: '28px',
                fontFamily: 'Arial',
                color: '#4A90E2',
                stroke: '#000000',
                strokeThickness: 4
            }).setOrigin(0.5).setDepth(201).setInteractive();
            
            restartButton.on('pointerover', () => {
                restartButton.setScale(1.1);
            });
            
            restartButton.on('pointerout', () => {
                restartButton.setScale(1);
            });
            
            restartButton.on('pointerdown', () => {
                this.scene.restart();
            });
            
            ElementSlicer.DevLog.log('GAME_WON', {
                score: ElementSlicer.State.score,
                maxCombo: ElementSlicer.State.maxCombo
            });
        }
        
        /**
         * åˆ›å»ºèƒœåˆ©æ˜Ÿæ˜Ÿæ•ˆæœ
         */
        createVictoryStars() {
            for (let i = 0; i < 20; i++) {
                const x = ElementSlicer.Utils.random(0, 800);
                const y = ElementSlicer.Utils.random(0, 600);
                const star = this.add.star(x, y, 5, 10, 20, 0xFFD700);
                star.setDepth(202);
                
                this.tweens.add({
                    targets: star,
                    scale: { from: 0, to: 1 },
                    rotation: { from: 0, to: Math.PI * 2 },
                    alpha: { from: 1, to: 0 },
                    duration: 2000,
                    delay: i * 100,
                    ease: 'Power2',
                    onComplete: () => star.destroy()
                });
            }
        }
        
        /**
         * æ›´æ–°å¾ªç¯
         */
        update(time, delta) {
            if (ElementSlicer.State.gameState !== 'playing') return;
            
            // æ›´æ–°å…ƒç´ 
            this.elements.children.entries.forEach(element => {
                if (!element || !element.active) return;
                
                // æ—‹è½¬å…ƒç´ 
                element.rotation += ElementSlicer.Config.elements.rotationSpeed * delta / 1000;
                
                // æ›´æ–°æ–‡æœ¬ä½ç½®
                if (element.symbolText) {
                    element.symbolText.x = element.x;
                    element.symbolText.y = element.y;
                }
                
                // ç§»é™¤è¶…å‡ºå±å¹•çš„å…ƒç´ 
                if (element.y < -100 || element.y > 700 || 
                    element.x < -100 || element.x > 900) {
                    this.destroyElement(element);
                }
            });
            
            // é™åˆ¶åœºæ™¯ä¸­çš„å…ƒç´ æ•°é‡
            if (this.elements.children.entries.length > 20) {
                console.warn('Too many elements:', this.elements.children.entries.length);
                // ç§»é™¤æœ€è€çš„å…ƒç´ 
                const oldElements = this.elements.children.entries.slice(0, -20);
                oldElements.forEach(element => {
                    if (element && element.active) {
                        this.destroyElement(element);
                    }
                });
            }
            
            // åŠ¨æ€è°ƒæ•´éš¾åº¦
            this.updateDifficulty();
        }
        
        /**
         * æ›´æ–°éš¾åº¦
         */
        updateDifficulty() {
            // æ¯30ç§’å¢åŠ éš¾åº¦
            const elapsedTime = this.time.now / 1000; // è½¬æ¢ä¸ºç§’
            const difficultyLevel = Math.floor(elapsedTime / 30);
            
            if (difficultyLevel > ElementSlicer.State.level - 1) {
                ElementSlicer.State.level = difficultyLevel + 1;
                
                // å‡å°‘ç”Ÿæˆé—´éš”
                const newInterval = Math.max(
                    ElementSlicer.Config.game.minSpawnInterval,
                    ElementSlicer.Config.game.spawnInterval - (difficultyLevel * 200)
                );
                
                if (newInterval !== ElementSlicer.State.currentSpawnInterval) {
                    ElementSlicer.State.currentSpawnInterval = newInterval;
                    
                    // é‡æ–°è®¾ç½®ç”Ÿæˆå®šæ—¶å™¨
                    if (this.spawnTimer) {
                        this.spawnTimer.remove();
                    }
                    
                    this.spawnTimer = this.time.addEvent({
                        delay: newInterval,
                        callback: this.spawnElement,
                        callbackScope: this,
                        loop: true
                    });
                    
                    ElementSlicer.DevLog.log('DIFFICULTY_INCREASED', {
                        level: ElementSlicer.State.level,
                        spawnInterval: newInterval
                    });
                }
            }
        }
    }
    
    // ==================== æ¸¸æˆåˆå§‹åŒ– ====================
    window.addEventListener('load', () => {
        // Phaser æ¸¸æˆé…ç½®
        const config = {
            type: Phaser.AUTO,
            width: ElementSlicer.Config.canvas.width,
            height: ElementSlicer.Config.canvas.height,
            parent: 'game-container',
            backgroundColor: '#1a1a2e',
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            },
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: GameScene,
            
            // ç§»åŠ¨ç«¯ä¼˜åŒ–
            input: {
                activePointers: 3  // æ”¯æŒå¤šç‚¹è§¦æ§
            }
        };
        
        // åˆ›å»ºæ¸¸æˆå®ä¾‹
        const game = new Phaser.Game(config);
        
        // ä¿å­˜æ¸¸æˆå®ä¾‹å¼•ç”¨
        ElementSlicer.gameInstance = game;
        
        // è°ƒè¯•å‘½ä»¤
        window.ElementSlicer = ElementSlicer;
        
        // æ·»åŠ è°ƒè¯•åŠŸèƒ½
        ElementSlicer.debug = {
            // æ˜¾ç¤ºå½“å‰çŠ¶æ€
            showState: () => console.table(ElementSlicer.State),
            
            // è®¾ç½®åˆ†æ•°
            setScore: (score) => {
                ElementSlicer.State.score = score;
                const scene = game.scene.getScene('GameScene');
                if (scene) scene.updateScore();
            },
            
            // æ·»åŠ ç”Ÿå‘½
            addLife: () => {
                ElementSlicer.State.lives++;
                console.log('ç”Ÿå‘½å€¼:', ElementSlicer.State.lives);
            },
            
            // æ˜¾ç¤ºFPS
            showFPS: () => {
                game.config.fps = {
                    target: 60,
                    forceSetTimeOut: true,
                    showFPS: true
                };
            },
            
            // æ¸…ç†æ‰€æœ‰å…ƒç´ 
            clearAllElements: () => {
                const scene = game.scene.getScene('GameScene');
                if (scene && scene.elements) {
                    scene.elements.children.entries.forEach(element => {
                        if (element) {
                            if (element.symbolText) {
                                element.symbolText.destroy();
                            }
                            element.destroy();
                        }
                    });
                    console.log('å·²æ¸…ç†æ‰€æœ‰å…ƒç´ ');
                }
            },
            
            // é‡å¯æ¸¸æˆ
            restart: () => {
                const scene = game.scene.getScene('GameScene');
                if (scene) {
                    scene.scene.restart();
                }
            },
            
            // åˆ›å»ºæµ‹è¯•å…ƒç´ 
            createTestElement: () => {
                const scene = game.scene.getScene('GameScene');
                if (scene) {
                    // åˆ›å»ºä¸€ä¸ªç®€å•çš„çº¢è‰²çŸ©å½¢ä½œä¸ºæµ‹è¯•
                    const testElement = scene.add.rectangle(400, 300, 80, 80, 0xFF0000);
                    scene.physics.add.existing(testElement);
                    testElement.body.setVelocity(0, -200);
                    testElement.body.setGravity(0, 300);
                    console.log('åˆ›å»ºäº†æµ‹è¯•å…ƒç´ ï¼ˆçº¢è‰²æ–¹å—ï¼‰');
                }
            }
        };
        
        ElementSlicer.DevLog.log('GAME_INITIALIZED', 'æ¸¸æˆåˆå§‹åŒ–å®Œæˆ');
    });
    </script>
</body>
</html>