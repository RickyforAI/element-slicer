<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…ƒç´ åˆ‡åˆ‡ä¹ - Canvasç‰ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        canvas {
            border: 2px solid #16213e;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(94, 84, 142, 0.5);
            cursor: crosshair;
        }
        
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 20px;
        }
    </style>
</head>
<body>
    <div class="info">
        <div>åˆ†æ•°: <span id="score">0</span></div>
        <div>ç”Ÿå‘½: <span id="lives">â¤ï¸â¤ï¸â¤ï¸</span></div>
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <script>
    // æ¸¸æˆé…ç½®
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    
    // æ¸¸æˆçŠ¶æ€
    let score = 0;
    let lives = 3;
    let elements = [];
    let sliceTrail = [];
    let isSlicing = false;
    let lastSpawnTime = 0;
    let spawnInterval = 2000;
    
    // å…ƒç´ ç±»å‹é…ç½®
    const elementTypes = {
        normal: { color: '#4A90E2', symbols: ['C', 'N', 'O', 'H'], score: 5 },
        toxic: { color: '#4CAF50', symbols: ['F', 'Cl', 'Br'], score: 8 },
        phantom: { color: '#00BCD4', symbols: ['He', 'Ne', 'Ar'], score: 15 },
        explosive: { color: '#FF4444', symbols: ['Li', 'Na', 'K'], score: 0 }
    };
    
    // å…ƒç´ ç±»
    class Element {
        constructor(x, y, type) {
            this.x = x;
            this.y = y;
            this.vx = Math.random() * 100 - 50;
            this.vy = -400;
            this.radius = 40;
            this.type = type;
            const typeConfig = elementTypes[type];
            this.color = typeConfig.color;
            this.symbol = typeConfig.symbols[Math.floor(Math.random() * typeConfig.symbols.length)];
            this.score = typeConfig.score;
            this.health = type === 'phantom' ? 3 : 1;
            this.rotation = 0;
        }
        
        update(deltaTime) {
            // æ›´æ–°ä½ç½®
            this.x += this.vx * deltaTime;
            this.y += this.vy * deltaTime;
            
            // é‡åŠ›
            this.vy += 300 * deltaTime;
            
            // æ—‹è½¬
            this.rotation += 2 * deltaTime;
        }
        
        draw() {
            ctx.save();
            
            // ç»˜åˆ¶åœ†å½¢
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶è¾¹æ¡†
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ç»˜åˆ¶ç¬¦å·
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.symbol, this.x, this.y);
            
            // ç»˜åˆ¶é»‘è‰²æè¾¹
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.strokeText(this.symbol, this.x, this.y);
            
            ctx.restore();
        }
        
        isOffScreen() {
            return this.y < -100 || this.y > 700 || this.x < -100 || this.x > 900;
        }
        
        checkCollision(x, y) {
            const dx = this.x - x;
            const dy = this.y - y;
            return Math.sqrt(dx * dx + dy * dy) < this.radius + 10;
        }
    }
    
    // ç”Ÿæˆå…ƒç´ 
    function spawnElement() {
        const types = ['normal', 'toxic', 'phantom', 'explosive'];
        const weights = [0.5, 0.2, 0.15, 0.15];
        
        let random = Math.random();
        let typeIndex = 0;
        let sum = 0;
        for (let i = 0; i < weights.length; i++) {
            sum += weights[i];
            if (random < sum) {
                typeIndex = i;
                break;
            }
        }
        
        const x = Math.random() * 600 + 100;
        const element = new Element(x, 650, types[typeIndex]);
        elements.push(element);
        
        console.log(`ç”Ÿæˆå…ƒç´ : ${element.type} (${element.symbol})`);
    }
    
    // å¤„ç†åˆ‡å‰²
    function handleSlice(element) {
        switch (element.type) {
            case 'normal':
                score += element.score;
                elements.splice(elements.indexOf(element), 1);
                break;
                
            case 'toxic':
                score += element.score;
                elements.splice(elements.indexOf(element), 1);
                // æ·»åŠ æ¯’é›¾æ•ˆæœ
                ctx.fillStyle = 'rgba(76, 175, 80, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                setTimeout(() => {
                    // 3ç§’åæ¸…é™¤æ•ˆæœ
                }, 3000);
                break;
                
            case 'phantom':
                element.health--;
                if (element.health <= 0) {
                    score += element.score;
                    elements.splice(elements.indexOf(element), 1);
                } else {
                    // åŠ é€Ÿé€ƒè·‘
                    element.vx *= 1.5;
                    element.vy *= 1.2;
                }
                break;
                
            case 'explosive':
                lives--;
                elements.splice(elements.indexOf(element), 1);
                updateLives();
                // å±å¹•éœ‡åŠ¨æ•ˆæœ
                canvas.style.animation = 'shake 0.3s';
                setTimeout(() => {
                    canvas.style.animation = '';
                }, 300);
                break;
        }
        
        updateScore();
    }
    
    // æ›´æ–°åˆ†æ•°
    function updateScore() {
        scoreEl.textContent = score;
        if (score >= 300) {
            alert('æ¸¸æˆèƒœåˆ©ï¼');
            location.reload();
        }
    }
    
    // æ›´æ–°ç”Ÿå‘½å€¼
    function updateLives() {
        let hearts = '';
        for (let i = 0; i < lives; i++) {
            hearts += 'â¤ï¸';
        }
        for (let i = lives; i < 3; i++) {
            hearts += 'ğŸ’”';
        }
        livesEl.textContent = hearts;
        
        if (lives <= 0) {
            alert('æ¸¸æˆç»“æŸï¼');
            location.reload();
        }
    }
    
    // é¼ æ ‡äº‹ä»¶
    canvas.addEventListener('mousedown', (e) => {
        isSlicing = true;
        sliceTrail = [];
    });
    
    canvas.addEventListener('mousemove', (e) => {
        if (!isSlicing) return;
        
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        sliceTrail.push({ x, y });
        if (sliceTrail.length > 20) {
            sliceTrail.shift();
        }
        
        // æ£€æµ‹ç¢°æ’
        elements.forEach(element => {
            if (element.checkCollision(x, y)) {
                handleSlice(element);
            }
        });
    });
    
    canvas.addEventListener('mouseup', () => {
        isSlicing = false;
        sliceTrail = [];
    });
    
    // è§¦æ‘¸äº‹ä»¶
    canvas.addEventListener('touchstart', (e) => {
        isSlicing = true;
        sliceTrail = [];
        e.preventDefault();
    });
    
    canvas.addEventListener('touchmove', (e) => {
        if (!isSlicing) return;
        
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches[0];
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;
        
        sliceTrail.push({ x, y });
        if (sliceTrail.length > 20) {
            sliceTrail.shift();
        }
        
        // æ£€æµ‹ç¢°æ’
        elements.forEach(element => {
            if (element.checkCollision(x, y)) {
                handleSlice(element);
            }
        });
        
        e.preventDefault();
    });
    
    canvas.addEventListener('touchend', () => {
        isSlicing = false;
        sliceTrail = [];
    });
    
    // æ¸¸æˆå¾ªç¯
    let lastTime = 0;
    function gameLoop(currentTime) {
        const deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;
        
        // æ¸…ç©ºç”»å¸ƒ
        ctx.fillStyle = '#16213e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // ç»˜åˆ¶æ ‡é¢˜
        ctx.fillStyle = '#FFFFFF';
        ctx.font = 'bold 36px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('å…ƒç´ åˆ‡åˆ‡ä¹', canvas.width / 2, 50);
        
        // ç”Ÿæˆå…ƒç´ 
        if (currentTime - lastSpawnTime > spawnInterval) {
            spawnElement();
            lastSpawnTime = currentTime;
            
            // é€æ¸åŠ å¿«ç”Ÿæˆé€Ÿåº¦
            if (spawnInterval > 1000) {
                spawnInterval -= 10;
            }
        }
        
        // æ›´æ–°å’Œç»˜åˆ¶å…ƒç´ 
        elements = elements.filter(element => {
            element.update(deltaTime);
            
            if (element.isOffScreen()) {
                return false;
            }
            
            element.draw();
            return true;
        });
        
        // ç»˜åˆ¶åˆ‡å‰²è½¨è¿¹
        if (sliceTrail.length > 1) {
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            ctx.beginPath();
            ctx.moveTo(sliceTrail[0].x, sliceTrail[0].y);
            
            for (let i = 1; i < sliceTrail.length; i++) {
                const alpha = i / sliceTrail.length;
                ctx.globalAlpha = alpha;
                ctx.lineTo(sliceTrail[i].x, sliceTrail[i].y);
            }
            
            ctx.stroke();
            ctx.globalAlpha = 1;
            
            // å¤–å‘å…‰æ•ˆæœ
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 8;
            ctx.stroke();
        }
        
        requestAnimationFrame(gameLoop);
    }
    
    // æ·»åŠ CSSåŠ¨ç”»
    const style = document.createElement('style');
    style.textContent = `
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
    `;
    document.head.appendChild(style);
    
    // å¼€å§‹æ¸¸æˆ
    requestAnimationFrame(gameLoop);
    
    console.log('æ¸¸æˆå·²å¯åŠ¨ - Canvasç‰ˆæœ¬');
    </script>
</body>
</html>